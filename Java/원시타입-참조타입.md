## Java의 자료형

자바의 자료형에는 **원시 타입**(Primitive type), **참조 타입**(Reference type) 두가지 타입이 있다.

**원시 타입**은 쉽게 말해 정수, 실수, 문자, 논리 리터럴 등의 **실제 데이터 값을 저장하는 타입**이고,

**참조 타입**은 객체(Object)의 번지를 참조(주소를 저장)하는 타입으로 **메모리 번지 값을 통해 객체를 참조하는 타입**이다.

## 원시 타입

| 종류 | 데이터형 | 크기(byte / bit) | 표현 범위 |
| --- | --- | --- | --- |
| 논리형 | boolean | 1 / 8 | true 또는 false |
| 문자형 | char | 2 / 16 | ‘\u0000’ ~ ‘uFFFF’(16비트 유니코드 문자 데이터) |
| 정수형 | byte | 1 / 8 | -128 ~ 127 |
| 정수형 | short | 2 / 16 | -32768 ~ 32767 |
| 정수형 | int | 4 / 32 | -2147483648 ~ 2147483647(-21억 ~ + 21억) |
| 정수형 | long | 8 / 64 | -9223372036854775808 ~ 9223372036854775807(-100경 ~ + 100경) |
| 실수형 | float | 4 / 32 | 1.4E-45 ~ 3.4028235E38 |
| 실수형 | double | 8 / 64 | 4.9E-324 ~ 1.7976931348623157E308 |
- **boolean**
    - 저장 가능한 범위 true / false
    - 자바가 데이터를 다루는 최소 범위가 1 Byte 이기 때문에 낭비적이지만, 1 Byte를 사용한다.
- **char**
    - 자바의 경우 Unicode를 사용하는데, 동양의 글자의 경우 2 Byte가 필요하기 때문에 char 의 경우 2 Byte를 사용한다.
    - **자바에서 유일하게 제공되는 unsigned 형태**이다.
        
        unsigned: 음수 없이 0부터 시작하여 양수 값만 가지는 데이터 형태
        

### char 연산 시 주의할 점

![스크린샷 2023-11-25 오전 11.57.44.png](https://github.com/Instagram-clone-project-team/Instagram-clone/assets/112863029/b82ba161-89d9-4b55-a235-99d144087410)

**JVM**은 연산할 때 **피연산자 스택을 활용**한다. 예를 들어 13 + 7 + 20을 계산할 경우 20 + 7을 계산한 결과를 스택에 집어 넣고, 다시 27 + 13을 계산한 결과를 스택에 집어 넣는 방식을 반복한다.

이때 주의할 점은 **JVM의 피연산자 스택은 피연산자를 4Byte 단위로 저장**다는 것인데, char나 short와 같이 int보다 작은 자료형의 값을 계산하면 int형으로 자동 형 변환이 되어 연산이 수행된다.

**정수형 데이터를 사용**하게 되면 **JVM에서 기본적으로 int형 데이터타입의 데이터로 인식**을 해주는데, 만약 **int형 데이터 타입의 범위를 넘어서는 long 데이터 타입의 정수를 사용하고자 하는 경우에는 정수 데이터 맨 뒤 쪽에 접미사 ‘I’ 또는 ‘L’을 붙여줘야 한다.**

참고로 소문자 I는 숫자 1과 혼동될 우려가 있기 때문에 **대문자 L**을 사용하는 것이 좋다.

## 참조 타입

참조 타입은 원시 타입을 제외한 타입으로 **객체의 주소를 저장하는 타입**이다. 참조 타입에는 문자열, 배열, 열거, 클래스, 인터페이스가 있다.

자바에서 **실제 객체**는 **JVM 힙 영역에 저장**되며, **참조 타입 변수**는 실제 객체의 주소를 **JVM 스택 영역에 저장**한다. 그리고 객체를 사용할 때마다 참조 변수에 저장된 객체의 주소를 불러와 사용하게 된다.

예시로 `Person p = new Person();` 이라는 코드를 작성했다면, `p`라는 이름의 메모리 공간이 스택 영역에 생성되고, 생성된 `p`의 인스턴스는 힙 영역에 생성된다. 즉, 스택 영역에 생성된 참조 변수 `p`는 힙 영역에 생성된 `p`의 인스턴스 주소 값을 가지게 되는 것이다.

### 정적 메모리 스택(Stack) 영역

**스택 영역에는 기본타입 변수가 할당되고, 변수의 실제 값들이 저장**된다.

**참조 타입의 변수들은 이 스택 영역에서 힙 영역에 생성된 객체들의 주소 값을 저장**하고 있다.

객체 안 메소드의 작업이 종료되면, 할당 되었던 메모리 공간은 반환되어 비워진다.

### 동적 메모리 힙(Heap) 영역

힙 영역에는 객체와 배열이 생성된다.

**참조 타입(배열, 클래스, 인터페이스 등) 들이 해당 객체들의 주소를 스택 영역에 저장**한다.

**기본 타입 변수들과는 다르게 크기가 정해져 있지 않다.** 

**프로그램 실행시 메모리에 동적으로 할당**된다.

**참조하는 변수가 없으면, 자바의 GC가 제거**한다.

## Boxing, Unboxing

**Boxing**은 **원시 타입을 참조 타입으로 변환** 시키는 것이고, **Unboxing**은 **참조 타입을 원시 타입으로 변환** 시키는 것을 말한다.

자바 1.5 이전에는 일일히 변환 과정을 거쳐주어야 했지만, 자바 1.5부터는 `Auto Boxing / Unboxing` 기능으로 아래와 같이 명시적으로 원시타입을 참조 타입으로 감싸주지 않아도 자동으로 변환해준다.

```java
int i = 10;
Integer integer = i;
```

하지만 이러한 `Auto Boxing / Unboxing` 기능은 메모리 누수의 원인이 될 수도 있다.

## 원시 타입과 참조 타입의 차이

### 성능 관점

![Untitled](https://github.com/Instagram-clone-project-team/Instagram-clone/assets/112863029/d1142fca-1cce-409b-9a14-834f2984c8e0)

**원시 타입**은 **스택 메모리에 값이 존재**한다.

반면에 **참조 타입**은 하나의 인스턴스이기 때문에 **스택 메모리에는 참조 값만 있고, 실제 값은 힙 메모리에 존재**한다. 

즉, **참조 타입은 최소 2번 메모리 접근을 해야하고, 일부 타입의 경우 값을 필요로 할 때 언박싱 과정을 거쳐야 하므로 원시 타입과 비교해서 접근 속도가 느리다.**

### 메모리 관점

| 원시 타입이 사용하는 메모리 | 참조 타입이 사용하는 메모리 |
| --- | --- |
| boolean - 1bit | Boolean - 128 bits |
| byte - 8bits | Byte - 128bits |
| short, cagr - 16bits | Short, Charater - 128bits |
| int, float - 32bits | Integer, Float - 128bits |
| long, double - 64bits | Long, Double - 196bits |

원시 타입보다 **참조 타입이 사용하는 메모리양이 압도적으로 높다.**

따라서 메모리 사용적으로도 **원시 타입이 참조 타입보다 효율적으로 사용할 수 있다.**

### Null 관점

원시 타입은 null을 담을 수 없지만, **참조 타입은 가능**하다.

```java
// 불가능
int i = null;

// 가능
Integer integer = null;
```

### 제네릭 관점

원시 타입은 제네릭 타입에서 사용할 수 없지만, **참조 타입은 가능**하다.

```java
// 불가능
List<i> list;

// 가능
List<Integer> list;
```

**참고 자료**

- <https://steady-coding.tistory.com/606>
- [https://velog.io/@gillog/원시타입-참조타입Primitive-Type-Reference-Type](https://velog.io/@gillog/%EC%9B%90%EC%8B%9C%ED%83%80%EC%9E%85-%EC%B0%B8%EC%A1%B0%ED%83%80%EC%9E%85Primitive-Type-Reference-Type)
- [https://kedric-me.tistory.com/entry/Java-원시-타입Primitive-type-참조-타입Reference-type-래퍼클래스Wrapper-Class](https://kedric-me.tistory.com/entry/Java-%EC%9B%90%EC%8B%9C-%ED%83%80%EC%9E%85Primitive-type-%EC%B0%B8%EC%A1%B0-%ED%83%80%EC%9E%85Reference-type-%EB%9E%98%ED%8D%BC%ED%81%B4%EB%9E%98%EC%8A%A4Wrapper-Class)
- <https://dream-and-develop.tistory.com/93>
