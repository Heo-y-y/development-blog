# 리덕스 툴킷(redux toolkit)

## 리덕스 툴킷이란?

Redux 툴킷은 Redux 로직을 작성하기 위한 공식 원장 접근 방식이다. Redux 코어를 둘러싸고 있으며, Redux 앱을 빌드하는 데 필수적이라고 생각하는 패키지와 기능이 포함되어 있다. Redux 툴킷은 제안된 모법 사례를 기반으로 하여 대부분의 Redux 작업을 단순화하고 일반적인 실수를 방지하고 Redux 애플리케이션을 더 쉽게 작성할 수 있도록 한다.

### 리덕스 툴킷으로 만들어진 카운터 앱 살펴보기

**리덕스 툴킷 설치**

```jsx
npx create-react-app ./  --template redux-typescript
```

![스크린샷 2024-01-24 오후 12.43.09.png](https://github.com/Heo-y-y/development-blog/assets/112863029/0341e81c-fcab-4044-ae68-abfd4e06f2fc)

**기본 소스 코드 살펴보기**

```json
"dependencies": {
    "@reduxjs/toolkit": "^1.9.7", // <- 둘다 설치해야 함
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^14.5.2",
    "@types/jest": "^27.5.2",
    "@types/node": "^17.0.45",
    "@types/react": "^18.2.48",
    "@types/react-dom": "^18.2.18",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-redux": "^8.1.3",
    "react-scripts": "5.0.1",
    "typescript": "^4.9.5",
    "web-vitals": "^2.1.4" // <- 둘다 설치해야 함
  },
```

**Store 생성하기**

```tsx
import { configureStore } from '@reduxjs/toolkit';

export const store = configureStore({
  reducer: {}
});
```

**React에 Redux 스토어 제공**

저장소가 생성되면 `src/index.js`에서 애플리케이션 주위에 React-Redux<Provider>를 배치하여 React 구성 요소에서 사용할 수 있도록 할 수 있다. 방금 만든 Redux 저장소를 가져오고 주위에 <Provider> 를 배치하고 저장소를 prop으로 전달한다.

```tsx
import { Provider } from 'react-redux';
import { store } from './app/store';

const container = document.getElementById('root')!;
const root = createRoot(container);

root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
);
```

**Redux State slice 생성**

`src/features/counter/counterSlice.js`라는 새 파일을 추가한다. 해당 파일에서 Redux Toolkit의 createSlice API를 가져온다.

```tsx
import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../app/store';
import { fetchCount } from './counterAPI';

export interface CounterState {
  value: number;
  status: 'idle' | 'loading' | 'failed';
}

const initialState: CounterState = {
  value: 0,
  status: 'idle',
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const incrementAsync = createAsyncThunk(
  'counter/fetchCount',
  async (amount: number) => {
    const response = await fetchCount(amount);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const counterSlice = createSlice({
  name: 'counter',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    increment: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(incrementAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(incrementAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.value += action.payload;
      })
      .addCase(incrementAsync.rejected, (state) => {
        state.status = 'failed';
      });
  },
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectCount = (state: RootState) => state.counter.value;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const incrementIfOdd =
  (amount: number): AppThunk =>
  (dispatch, getState) => {
    const currentValue = selectCount(getState());
    if (currentValue % 2 === 1) {
      dispatch(incrementByAmount(amount));
    }
  };

export default counterSlice.reducer;
```

slice의 이름, 초기 상태, 어떻게 변경되는지

Redux 툴킷을 사용하면 리듀서에서 “변경” 로직은 작성할 수 있다. 그것은 immer 라이브러리를 사용하기 때문에 실제로 상태를 변경하지 않는다.

“초인(draft) 상태” 에 대한 변경 사항을 감지하고 이러한 변경 사항을 기반으로 완전히 새로운 불변(immutable) 상태를 생성한다.

**스토어에 Slice Reducer 추가**

다음으로 카운터 슬라이스에서 리듀서 함수를 가져와서 스토어에 추가해야 한다. 리듀서 매개변수 내부에 필드를 정의함으로써 스토어에 이 슬라이스 리듀서 함수를 사용하여 해당 상태에 대한 모든 업데이트를 처리하도록 지시한다.

```jsx
import counterReducer from '../features/counter/counterSlice'

export const store = configureStore ({
	reducer: {
		counter: counterReducer,
	},
})
```

**React 컴포넌트에서 Redux State 및 Actions 사용**

**useSelector**를 사용하여 저장소에서 데이터를 읽고, **useDispatch**를 사용하여 Action을 전달할 수 있다.

```jsx
export function Counter() {
 const count = useSelector((state: RootState) =? state.counter.value)
 const dispatch = useDispatch()
```

```jsx
<button
	aria-label="Increment value"
	onClick={() => dispatch(increament())}
>
	Increment
</button>
```

---

**참고 자료**

- <https://fastcampus.co.kr/dev_online_frontend>
