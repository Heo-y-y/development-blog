# List and Keys

## **List와 Key**

### List

리스트는 우리말로 목록이라는 뜻을 가지고 있다. 컴퓨터 프로그래밍에서는 **같은 아이템을 순서대로 모아 놓은 것**이 **리스트**에 해당한다. 

리스트를 위해 사용하는 자료 구조가 바로 **배열**(**Array**)이다. 배열은 **자바스크립트의 변수나 객체들을 하나의 변수로 묶어 놓은 것**이다.

**배열 예시**

```jsx
const numbers = [1, 2, 3, 4, 5];
```

리액트에서는 배열을 사용해서 리스트 형태로 엘리먼트들을 렌더링할 수 있다.

### Key

key라는 영어 단어는 열쇠라는 뜻을 가지고 있다.

그러면 우리가 알고 있는 열쇠의 특징은 뭐가 있을까?

바로 열쇠는 모두 다 모양이 다르다는 것이다. 다시 말해 열쇠는 각자 **고유**하다는 것이다. 이와 같은 맥락으로 컴퓨터 프로그래밍에서의 **key**는 **각 객체나 아이템을 구분할 수 있는 고유한 값**이다. 그리고 **리액트**에서의 **key**는 **리스트에 존재하는 아이템들을 구분하기 위한 고유한 문자열**을 의미한다.

## 여러 개의 Component 렌더링하기

리액트에서는 위에서 나온 배열과 키를 활용하여 반복되는 여러 개의 컴포넌트들을 쉽게 렌더링할 수 있다. 즉, 반복되는 다수의 엘리먼트가 렌더링 되는 것이다.

### map()

map 함수는 영단어 mapping을 떠올리면 기억하기 쉽다. mapping이라고 하면 한쪽에 있는 아이템과 다른 한쪽에 있는 아이템을 짝지어 준다는 의미를 가지고 있는데, 여기에서의 mapping도 마찬가지로 **배열에 들어있는 각 변수에 어떤 처리를 한 뒤 리턴하는 것**으로 이해하면 된다.

**예제 코드**

```jsx
const doubled = numbers.map((number) => number * 2);
```

위 코드는 map 함수를 사용하여 `numbers` 배열에 들어있는 각 숫자에 2를 곱한 값이 들어간 `dubled`라는 배열을 생성하는 코드이다.

이처럼 **map 함수**는 **배열의 첫번째 아이템부터 순서대로 각 아이템의 어떠한 연산을 수행한 뒤에 최종 결과를 배열로 만들어서 리턴**해 준다고 생각하면 된다.

그렇다면 실제로 리액트에서는 map 함수를 어떻게 사용하여 엘리먼트를 렌더링할까?

**예제 코드**

```jsx
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =>
    <li>{number}</li>
);

ReactDOM.render(
    <nl>{listItems}</nl>,
    document.getElementById('root')
);
```

위 코드는 리액트에서 map 함수를 사용하여 엘리먼트를 렌더링하는 코드이다. 

코드를 살펴보면, 숫자 1부터 5까지 들어있는 `numbers`라는 배열이 있고, map 함수를 사용해서 이 배열에 들어있는 각 숫자를 `li` 태그로 감싸서 리턴하고 있다. JSX에서는 중괄호를 사용하면 자바스크립트 코드를 넣을 수 있기 때문에 각 숫자의 값이 태그 안에 들어가게 된다. 이렇게 리턴된 `listItems`의 배열은 총 5개의 엘리먼트를 갖고 있게 된다.

그리고 이것을 화면에 렌더링하기 위해 `React.DOM`에 렌더 함수를 사용했다. 결과적으로 `li` 태그가 들어있는 `listItems` 배열을 ul 태그로 감싸서 렌더링하게 된다. 

최종적으로 렌더링되는 코드는 아래와 같다.

```jsx
ReactDOM.render(
    <nl>
        <li>{1}</li>
        <li>{2}</li>
        <li>{3}</li>
        <li>{4}</li>
        <li>{5}</li>
    </nl>,
    document.getElementById('root')
);
```

### 기본적인 List Component

이제 위 코드를 기본적인 형태를 가진 별도의 리스트 컴포넌트로 분리해보자.

**예제 코드**

```jsx
function NumberList(props) {
    const { numbers } = props;

    const listItems = numbers.map((number) =>
        <li>{number}</li>
    );

    return (
        <ul>{listItems}</ul>
    );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
    <NumberList numbers={numbers /}>,
    document.getElementById('root')
);
```

위 코드는 숫자 목록을 출력하는 NumberList 컴포넌트이다.

`NumberList` 컴포넌트는 `props`로 숫자가 들어있는 배열인 `numbers`를 받아서 이를 목록으로 출력한다. 이 `NumberList` 컴포넌트를 사용하면 `numbers` 배열의 숫자가 수십 개 또는 수백 개가 되어도 별도의 코드를 작성할 필요 없이 화면에 렌더링 할 수 있다.

하지만 위 코드를 실행하면 아래와 같은 경고문이 나온다.

![스크린샷1 2023-12-07 오후 5 24 44](https://github.com/Heo-y-y/development-blog/assets/112863029/171d809b-9d0e-4b43-858a-6bf0e5f344e5)

이 경고문은 **리스트의 각 아이템은 무조건 고유한 키를 갖고 있어야 한다**는 뜻이다.

즉, 현재 각 아이템에 키가 없기 때문이다.

## List의 Key

위에서 키가 가지고 있는 특징은 고유하다는 것이라고 했다. 그리고 리액트에서의 키는 리스트에서 아이템을 구분하기 위한 고유한 문자열이라고도 했다. **키**는 **리스트에서 어떤 아이템이 변경, 추가 또는 제거되었는지 구분**하기 위해 사용된다.

우리가 일상 생활에서 사용하고 있는 키는 주민등록번호, 학번, 핸드폰 번호, 여권 번호 등이 있다. 이 모두가 고유한 값이라는 특징을 가지고 있다. 하지만 고유하다는 특징은 그 범위가 한정되어 있다. **특정 범위에서만 고유하면 된다**는 것이다. 마찬가지로 **리액트에서의 키 값은 같은 리스트에 있는 엘리먼트 사이에서만 고유한 값이면 된다**.

![스크린샷 2023-12-07 오후 5.36.39.png](https://github.com/Heo-y-y/development-blog/assets/112863029/551017e4-1de2-410e-94a5-50bd4ef99660)

위 그림처럼 학번이 같지만, 학교 별로 구분해서 A대학교 학생들만 보면 학번이 모두 다르고 B대학교 학생들만 볼 경우도 마찬가지이다.

이처럼 학번은 대학교 내에서 학생을 구분하기 위한 일종의 키이기 때문에 속한 집합 내에서만 고유한 값이면 된다.

그렇다면 실제 리액트에서는 어떻게 적용될까?

아래 그림은 `NumberList` 컴포넌트를 나타낸 것이다.

![스크린샷 2023-12-07 오후 5.43.29.png](https://github.com/Heo-y-y/development-blog/assets/112863029/6eca25d4-763f-4bcd-b2f8-b642a891b3d5)

각 리스트의 아이템에는 키가 들어있다. 위 대학교 그림과 마찬가지로 두 개의 NumberList 간에 아이템들의 키값이 중복되는 것을 볼 수 있다. 하지만 이 역시 각 리스트 내에서 아이템을 구분하기 위한 용도이기 때문에 속한 리스트 내에서만 고유한 값이면 된다.

**key로 값을 사용하는 경우**

```jsx
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =>
    <li key={number.toString()}>
        {number}
    </li>
);
```

위 코드는 키 값으로 숫자의 값을 사용한 것이다. 이렇게 하면 지금처럼 `numbers` 배열의 숫자들이 중복되지 않는 경우에는 정상적으로 동작하지만 만약 `numbers` 배열에 중복된 숫자가 들어 있다면 키 값도 중복되기 때문에 고유해야 한다는 키 값의 조건이 충족되지 않는다.

**key로 id를 사용하는 경우**

```jsx
const todoItems = todos.map((todo) =>
    <li key={todo.id}>
        {todo.text}
    </li>
);
```

`id`의 의미 마체가 고유한 값이기 때문에 키 값으로 사용하기에 적합하다. 이렇게 `id`가 있는 경우에는 보통 `id`를 키 값으로 사용한다.

**key로 index를 사용하는 경우**

```jsx
const todoItems = todos.map((todo, index) =>
    // 아이템들의 고유한 ID가 없을 경우에만 사용해야 한다.
    <li key={index}>
        {todo.text}
    </li>
);
```

이 방법은 map 함수에서 두 번째 파라미터로 제공해주는 인덱스 값을 키 값으로 사용하는 것이다. 이 인덱스는 배열 내에서 현재 아이템의 인덱스를 의미한다. 인덱스도 고유한 값이기 때문에 키 값으로 사용해도 되지만, **배열에서 아이템의 순서가 바뀔 수 있는 경우에는 키 값으로 인덱스를 사용하는 것을 권장하지 않는다**. 성능에 부정적인 영향을 끼칠 수 있고, 컴포넌트의 state와 관련하여 문제를 일으킬 수도 있다.

참고로 리액트에서는 키를 명시적으로 넣어주지 않으면, 기본적으로 인덱스 값을 키 값으로 사용한다.

**참고 자료**

- [https://www.inflearn.com/course/lecture?courseSlug=처음-만난-리액트&unitId=113231&tab=curriculum](https://www.inflearn.com/course/lecture?courseSlug=%EC%B2%98%EC%9D%8C-%EB%A7%8C%EB%82%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8&unitId=113231&tab=curriculum)
