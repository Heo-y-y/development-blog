# 채팅 기능에 사용할 기술 선택

## 구현 준비

이번에 진행할 기능은 채팅 기능이다. SSE를 진행할 때 웹소켓, Polling, Long Polling 방식을 알아봐서 웹소켓 방식으로 하겠구나 인지하고 있었다.

우선 채팅 기능을 구현하기 위해 관련 레퍼런스들을 찾아보고 어떻게 시스템을 구현하고, 구성하는지 알아봤다. 지나가는 키워드들 중 **Kafka, Stomp, MogoDB, WebSocket** 이 많이 나왔는데, 중요한건 이중에서 한번도 써본 것이 없다는 것이다. 

일단 어떤 기술을 채택하여 사용할지 정하기 위해 비슷한 기술을 비교하고, 그 중 프로젝트에 맞는 기술을 채택하기로 결정했다.

## WebSocket vs Stomp

### WebSocket

웹 소켓은 HTML5 표준 기술로, HTTP 환경에서 클라이언트와 서버 사이에 **하나의 TCP 연결을 통해 실시간으로 전이중 통신을 가능**하게 하는 프로토콜이다.

웹 소켓이 개발되기 이전에는 Polling이나 Long Polling 방식으로 실시간은 아니지만 비슷하게 구현해서 문제를 해결해왔다고 한다.

Polling이나 Long Polling에 대해서는 SSE를 구현할 때 다뤘기 때문에 궁금하면 해당 링크에서 확인하면 된다.

[알림 기능의 통신 방법 고민](../알림기능/통신방법.md)

웹 소켓이 등장한 이후부터는 클라이언트와 서버간의 실시간 통신이 가능하게 되었다.

HTTP 통신에서는 연결을 지속하지 않고, 클라이언트가 서버로 단방향 요청만 가능하게 구성되어 있었다.

웹 소켓이 등장한 이후부터는 클라이언트와 서버간 연결을 지속적으로 유지하고 서버도 클라이언트로 클라이언트도 서버로 데이터를 보낼 수 있게 됨으로서 **양방향 통신**을 할 수 있게 되었다.

참고로 웹 소켓은 요청과 응답 개념이 아닌 서로 데이터를 주고 받는 형식을 취하고 있다.

그러면 웹 소켓만으로는 채팅 기능을 만들 수 없을까?

결론은 웹 소켓만으로 채팅을 만드는 것은 가능하다. 하지만 왜 Stomp와 비교해서 기술을 선택했을까?

### Stomp

웹 소켓 프로토콜은 **두 가지(텍스트, 바이너리) 유형의 메시지**를 정의하고 있지만 메시지의 내용까지는 정의하고 있지 않는다.

**Somp**는 **메시지 전송을 효율적으로 하기 위해 등장한 프로토콜**이다. 기본적으로 **pub/sub 구조**를 따르고 있기 때문에 메시지를 전송하고 메시지를 받아 처리하는 부분이 명확하다는 장점이 있다.

Somp를 사용해 채팅 시스템을 개발한다고 한다면 크게 2가지 행동이 있다고 볼 수 있다.

- 채팅방 입장: 현재 입장한 채팅방 번호를 구독한다.
- 채팅방에서 메시지를 보내거나 받기: 구독한 채팅방에서 메시지를 보내거나 받아볼 수 있다.

**Somp를 시용하면 좋은 점**

- 채팅 엔드포인트를 Spring Security를 이용하여 권한을 제어할 수 있다.
    - ex) 운영자만 입장 가능한 채팅방
- Publisher으로 부터 전달 받은 메시지를 Subscriber로 전달해줄 때 중간에서 메시지를 주고 받게 해주는 메시지 브로커를 사용할 수 있다.

Stomp를 사용하면 기본적으로 **In-Memory Message Broker**를 사용하게 되는데, 이로인해 생기는 여러가지 문제가 있다. 하지만 이 부분은 은 **RabbitMQ, Kafka, Active MQ와 같은 외부 브로커를 사용함으로서 문제를 해결**할 수 있다고 한다.

### 결론

현재 구현해야 하는 기능은 채팅 기능이다.

채팅을 초점에 두고 생각을 해보면, **WebSocket**은 어떤 채팅방에 현재 누가 접속중인지 알아야하고, 채팅방에 포함된 사용자에게 모두 메시지를 보내야 하기 때문에 **채팅마다 세션을 관리**해야하는 번거로움이 있다.

Stomp는 **사용자가 채팅방에 접속했을 때 해당 채팅방을 구독**하기만 한다면 누가 접속중인지 따로 관리하지 않아도 **메시지를 보낸 사용자가 포함된 채팅방의 모든 사람에게 메시지**가 갈 수 있다는 강점을 가지고 있다.

이러한 부분에서 채팅 기능에 좀 더 부합한 기술은 **Stomp**라고 판단하여 채택하게 되었다.

## **Kafka vs RabbitMQ**

메시지 큐를 떠올리면 대표적으로 Kafka와 RabbitMQ가 생각난다.

이 둘의 차이를 알아보자.

### **RabbitMQ**

**RabbitMQ**는 대표적인 **메시지 브로커**이다.

**메시지 브로커**란 **publisher가 생성한 메시지를 메시지 큐에 저장**하고, 저장된 데이터를 consumer가 소비할 수 있도록 **중간 다리 역할**을 해준다.

consumer가 큐에서 데이터를 가져가게 되면, 메시지 처리 후 **짧은 시간내에 데이터가 삭제**된다는 점을 주의해서 사용해야 한다. 전통적인 메시지 브로커의 형태를 따르고 있으며, 이러한 형태는 앱의 트래픽이 증가하여도 수 평적으로 확장하는 데에 어려움을 주게 된다.

이벤트 메시지가 성공적으로 전달되었다고 판단되면, 메시지 큐에서 삭제되기 때문에 다시 이벤트를 재생하기 어렵다는 단점도 존재한다.

### Kafka

**Kafka**는 대표적인 **이벤트 스트리밍 플랫폼**이다.

메시지 브로커와 이벤트 스트리밍 플랫폼 모두 이벤트를 수신하고, 이것을 **consumer에게 전달하는 데에 목적**이 있다는 것은 같다. 하지만 **이 둘의 작동 방식은 큰 차이**가 있다.

이벤트 스트리밍 플랫폼은 이벤트가 생성되면, 레코드 로그를 streamer에 기록하게 된다.

consumer가 topic을 가져간 후에도 **이벤트 스트림에서 로그를 계속 유지**하기 때문에 에러나 기타 문제가 생겼을 경우 이벤트를 재생할 수 있다는 강력한 장점이 있다.

이벤트 스트리밍 플랫폼은 전통적인 메시지 브로커에 비해 좀 더 유연하고 느슨한 결합을 가져갈 수 있게 되었다. 따라서 격리와 확장이 비교적 쉽다는 장점도 가지고 있다.

Kafka는 Zookeeper가 실행중이어야 사용할 수 있다. Zookeeper는 분산 코디네이션 시스템을 제공한다. **Kafka Cluster의 리더를 발탁하는 방식도 Zookeeper가 제공**하고 있다.

참고로 메시지 브로커는 이벤트 브로커가 될 수 없지만, **이벤트 브로커는 메시지 브로커 역할을 할 수 있다**.

### 결론

현재 인스타클론 프로젝트는 사이드 프로젝트이기 때문에 사용자가 있지는 않을 것이다. 하지만 이번 프로젝트의 목적은 최대한 실제 인스타그램의 기능을 구현하여 고가용성의 설계를 가진 애플리케이션을 만들어보자는 것이기 때문에 트래픽이 많고, 장애가 생겼을 때 대응할 수 있는 포인트가 좀 더 명확환 **Kafka**를 사용하기로 결정했다.

RabbitMQ도 exchange를 통한 pub/sub 구조를 구현할 수 있고, 충분히 채팅 시스템을 구현하는 것에는 지장이 없지만 추후 트래픽이 몰릴거라는 가정을 잡으면 Kafka가 조금 더 유연할 것으로 생각했다.

또한 느슨한 결합을 가져가면 이후에 프로젝트를 변경할 때 리팩토링에 더 좋을 것이라고 판단이 들었다.

## MongoDB vs MySQL

채팅방의 채팅 내용을 쓰고, 읽는 작업을 하기 위해서는 기존에 사용하는 MySQL을 계속 사용할지 MongoDB를 채팅전용 DB로 사용해야 할지에 대한 고민이 생겼다.

결론부터 말하면, 순수한 채팅방에 대한 데이터는 MySQL을 사용하고, 채팅 기록은 MongoDB를 사용하기로 결정했다.

MongoDB는 NoSQL의 한 종류이기 때문에 **RDB보다 더 빠른 읽기 쓰기 성능**을 가지고 있다. 채팅 내용은 언제든지 바뀔 수 있고, 많은 양의 데이터가 수시로 읽고 써진다는 특징이 있다. 이런 부분에서 MongoDB를 이용해서 채팅 데이터를 관리해주는 것이 성능적으로 이점을 가질 것이라 생각했다.

채팅방 부분만 MySQL을 이용해서 따로 관리하는 이유는 다음과 같다.

인스타그램 서비스에서 **채팅방의 PK(고유키)와 회원의 PK**는 어떤 회원의 채팅방 리스트를 조회할 때 꼭 필요한 정보이다. 결론적으로 회원이 채팅방 목록을 보려고 할 때 JOIN 연산이 불가피하므로, MySQL을 이용해 채팅방 정보를 유지하기로 결정했다.

회원이 채팅방 리스트를 조회할 때 한번만 조회 쿼리가 나가기 때문에 **수시로 읽고, 쓰는 채팅 내용보다는 훨씬 가벼운 작업**이기 때문에 관계형 데이터베이스이 장점은 살리고, NoSQL의 장점은 따로 가져가기로 결정했다.

---

**참고 자료**

- <https://coding-nyan.tistory.com/129>
- <[https://velog.io/@ch4570/Stomp-Kafka를-이용한-채팅-기능-개발하기-with-Spring-Boot-1-Kafka와-Stomp는-무엇일까](https://velog.io/@ch4570/Stomp-Kafka%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%B1%84%ED%8C%85-%EA%B8%B0%EB%8A%A5-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-with-Spring-Boot-1-Kafka%EC%99%80-Stomp%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)>
- <https://programming-workspace.tistory.com/69>
- <https://tecoble.techcourse.co.kr/post/2021-08-14-web-socket/>
